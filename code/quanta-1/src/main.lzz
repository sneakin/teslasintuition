/* Quanta 1 - physics simulation of colliding balls
 * Copyright (C) 2016 Nolan Eakins
 * All rights reserved.
 */

#src
#include <iostream>
#include <string>
#include <cmath>
#include "gl.h"
#include "sdl.h"

#include "real.h"
#include "vec3.h"
#include "matrix.h"
#include "colors.h"
#include "renderer.h"
#include "renderer/fps_camera.h"
#include "geometry/icosahedron_renderer.h"
#include "player_command_state.h"
#include "xpad.h"
#include "quanta.h"
#include "quanta_renderer.h"
#include "screen_shooter.h"
#include "shader_program.h"
#include "vertex_shader.h"
#include "fragment_shader.h"

#include "renderer/gl3/framebuffer.h"
#include "renderer/gl3/renderbuffer.h"
#include "renderer/gl3/framebuffer_texture.h"
#include "effects/motion_blur.h"
#include "effects/bloom.h"
#include "effects/downsampler.h"
#include "effects/gaussian_blur.h"

#define APP_TITLE "Quanta 1"
#define APP_LOGO "logo.bmp"
#define APP_WIDTH 800
#define APP_HEIGHT 600

#end

const std::string APP_TEXTURE_PATH = "assets/textures/";

#ifdef MAC
using std::isnan;
using std::isinf;
#endif

using std::cout;
using std::endl;


int window_width = APP_WIDTH, window_height = APP_HEIGHT;

int main(int argc, char *argv[])
{
  unsigned int frames = 0, ms_per_frame = 0, frame_start = 0;
  int joystick_index = 0;
  Real new_offset = 2.0, near_plane = 1.0, far_plane = 1024.0 * 4.0;
  int num_quanta = 125, universe_size = 2048, generation = 0;
  Real quantum_speed = 0.0, quantum_forward_speed = 0.0, quantum_radius = 0.5f, quantum_mass = 1.0;
  Real mp = quantum_radius * 2.5f;
  Vec3 min_position(-mp, -mp, -mp), max_position(mp, mp, mp);

  if(argc > 1) {
    num_quanta = atoi(argv[1]);
  }
  if(argc > 2) {
    Real n = ator(argv[2]);
    min_position = Vec3(-n, -n, -n);
    max_position = Vec3(n, n, n);
  }
  if(argc > 3) {
    universe_size = ator(argv[3]);;
  }
  if(argc > 4) {
    Real n = ator(argv[4]);
    quantum_speed = n;
  }
  if(argc > 5) {
    quantum_radius = ator(argv[5]);
  }
  if(argc > 6) {
    quantum_mass = ator(argv[6]);
  }

  SDL sdl(SDL_INIT_VIDEO|SDL_INIT_JOYSTICK);

  int num_displays = sdl.numberOfDisplays();
  int display = 1;
  cout << "Using display " << display << "/" << num_displays << endl;

  Window window(sdl, APP_TITLE, SDL_WINDOWPOS_CENTERED_DISPLAY(display), SDL_WINDOWPOS_CENTERED_DISPLAY(display), APP_WIDTH, APP_HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);

  Renderer renderer(window);
  if(GLEW_VERSION_3_2) {
    cout << "OpenGL 3.2 supported" << std::endl;
  }
  if(GLEW_VERSION_3_3) {
    cout << "OpenGL 3.3 supported" << std::endl;
  }
  if(GLEW_ARB_compatibility) {
    cout << "ARB compatibility supported" << std::endl;
  }
  if(!GLEW_ARB_vertex_array_object) {
    cout << "No vertex array support." << std::endl;
  }
  cout << "OpenGL version: " << glGetString(GL_VERSION) << std::endl;
  cout << "       vendor: " << glGetString(GL_VENDOR) << std::endl;
  cout << "       renderer: " << glGetString(GL_RENDERER) << std::endl;
  cout << "       SL version: " << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
  

  ASSERT_GL_ERROR;

  StockShaderProgram shader_2d(renderer, "shaders/basic_vertex.glsl", "shaders/basic_fragment.glsl");
  StockShaderProgram shader_3d(renderer, "shaders/basic_vertex_3d.glsl", "shaders/basic_lighting.glsl");
  Canvas2D canvas_2d(renderer);
  Canvas3D canvas_3d(renderer);
  
  Texture logo(APP_TEXTURE_PATH + APP_LOGO);

  GL3::Framebuffer &fb = renderer.defaultFramebuffer();
  //Texture fb_velocity(APP_WIDTH, APP_HEIGHT, GL_RGBA, false, false, GL_RGBA, GL_FLOAT);
  //fb.attachTexture(GL_COLOR_ATTACHMENT1, fb_velocity);
  //GLenum buffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };
  //fb.drawTo(2, buffers);

  const Vec3 fb_size(APP_WIDTH, APP_HEIGHT);
  GL3::FramebufferTexture fb1(APP_WIDTH, APP_HEIGHT), fb2(APP_WIDTH, APP_HEIGHT);
  GL3::FramebufferTexture scratch_fb(APP_WIDTH, APP_HEIGHT), scaled_fb(APP_WIDTH, APP_HEIGHT);
  GL3::FramebufferTexture *front = &fb1, *back = &fb2;

  MotionBlur mblur(canvas_2d);
  Bloom bloom(canvas_2d, 4, 5, scratch_fb, scaled_fb);

  SDL_Event event;
  bool done = false;
  bool is_paused = false;

  GLuint last_now = 0, now = SDL_GetTicks();

#if 1 //def TEST_SCENE
  Real x = 0.0, y = 0.0, scale = 1.0;

  canvas_2d.bind(shader_2d);
  canvas_2d.setProjectionMatrix(Matrix::orthographicProjection(0.0, 0.0, 10.0, 10.0, 100.0, -100.0));
  renderer.setClearColor(Vec3(0, 0, 0, 0));
  renderer.setDepthTest(GL_LEQUAL);

  Vec3 mouse = Vec3(1, 1), last_mouse = Vec3();

  while(!done) {
    while(SDL_PollEvent(&event)) {
      switch(event.type) {
      case SDL_MOUSEMOTION:
        if(!is_paused) {
          x = (Real)event.motion.x / (Real)APP_WIDTH * 10.0;
          y = (Real)event.motion.y / (Real)APP_HEIGHT * 10.0;
          last_mouse = mouse;
          mouse = Vec3(x, y, 0.0);
        }
        break;
      case SDL_MOUSEBUTTONDOWN:
        if(event.button.button == SDL_BUTTON_LEFT) {
          scale *= 2.0;
        } else {
          scale *= 0.5;
        }
        break;
      case SDL_KEYDOWN:
        switch(event.key.keysym.scancode) {
          case SDL_SCANCODE_RETURN:
            done = true;
            break;
          case SDL_SCANCODE_SPACE:
            is_paused = !is_paused;
            break;
         }
      }
    }

    if(!is_paused) {
      last_now = now;
      now = SDL_GetTicks();
    }

    //GLuint now = 0;
    renderer.updateTime(now);
    //renderer.setColorMatrix(Matrix::rotate(Vec3(now / 1000.0, now / 1000.0, now / 1000.0)));

    front->bindFramebuffer();
    renderer.setViewport(0, 0, fb_size.x(), fb_size.y());
    canvas_2d.bind(shader_2d);

    canvas_2d.pushProjectionMatrix(); {
      renderer.clear();
      //front->clear(1, Vec3(0.5, 0.5, 0.5));
      front->clear(1, Vec3::W);
      canvas_2d.setProjectionMatrix(Matrix::orthographicProjection(0.0, 0.0, 10.0, 10.0, 200.0, -200.0));
      canvas_2d.setVelocity(mouse - last_mouse);
      canvas_2d.setColor(Colors::White);
      canvas_2d.renderSprite(logo, mouse + Vec3(0.0, 0.0, -1.0), Vec3(0.5, 0.5, 0), Vec3(scale, scale, 1.0), 0); //now / 1000.0);
      canvas_2d.setVelocity(Vec3());
      canvas_2d.setColor(Colors::White);
      canvas_2d.renderSprite(back->colors(), Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0), Vec3(2.0, 2.0, 1.0), 0.0);
      canvas_2d.pushColorMatrix(); {
        canvas_2d.mulColorMatrix(Matrix::translation(0.5) * Matrix::scale(0.5));
        canvas_2d.renderSprite(back->velocity(), Vec3(0.0, 2.0, 0.0), Vec3(0.0, 0.0), Vec3(2.0, 2.0, 1.0), 0.0);
      } canvas_2d.popColorMatrix();
      canvas_2d.pushColorMatrix(); {
        Matrix m = Matrix::translation(Vec3(1.0, 1.0, 1.0)) * Matrix::scale(-1.0);
        canvas_2d.mulColorMatrix(m);
        canvas_2d.renderSprite(back->mydepth(), Vec3(0.0, 4.0, 0.0), Vec3(0.0, 0.0), Vec3(2.0, 2.0, 1.0), 0.0);
        canvas_2d.renderSprite(back->depth(), Vec3(0.0, 6.0, 0.0), Vec3(0.0, 0.0), Vec3(2.0, 2.0, 1.0), 0.0);
      } canvas_2d.popColorMatrix();
      canvas_2d.pushModelViewMatrix(); {
        canvas_2d.mulModelViewMatrix(Matrix::scale(Vec3(0.5, 0.5, 1.0)) * Matrix::translation(Vec3(5, 5)));
        for(int n = -10; n <= 10; n++) {
          Matrix r = Matrix::rotateZ(now * 2.0 * M_PI / 1000.0 * 0.5);
          Matrix next_r = Matrix::rotateZ((float)(now + (now - last_now)) * 2.0 * M_PI / 1000.0 * 0.5);
          Vec3 p = Matrix::translation(Vec3(0.0, 0.0, 10 * n)) * Matrix::rotateZ((float)n * 2.0 * M_PI / (float)10) * Matrix::scale(4.0) * Vec3::X;
          Vec3 np = r * p, op = next_r * p;
          canvas_2d.setVelocity(np - op);
          canvas_2d.renderSprite(logo, np, Vec3(0.5, 0.5), Vec3(scale / 2, scale / 2, 1.0), (float)n * 2.0 * M_PI / (float)10);
        }
      } canvas_2d.popModelViewMatrix();
    } canvas_2d.popProjectionMatrix();
    
    front->unbindFramebuffer();

    renderer.setViewport(0, 0, window_width, window_height);
    mblur.render(front->colors(), front->depth(), front->velocity(), front->bloom());
    
    renderer.swap();
    GL3::FramebufferTexture *t = front;
    front = back;
    back = t;
    
    ASSERT_GL_ERROR;
  }
#endif /* TEST_SCENE */
  
  SDL_Joystick *joystick = SDL_JoystickOpen(joystick_index);
  if(joystick == NULL) {
    std::cout << "Error opening joystick " << joystick_index << ": " << SDL_GetError() << endl;
    std::cout << "Try one of the following: " << std::endl;
    for(int i = 0; i < SDL_NumJoysticks(); i++) {
      std::cout << "\t" << SDL_JoystickNameForIndex(i) << std::endl;
    }
  } else {
    std::cout << "Joystick " << SDL_JoystickName(joystick) << " opened:" << std::endl;
    std::cout << "\tAxes: " << SDL_JoystickNumAxes(joystick) << std::endl;
    std::cout << "\tBalls: " << SDL_JoystickNumBalls(joystick) << std::endl;
    std::cout << "\tHats: " << SDL_JoystickNumHats(joystick) << std::endl;
    std::cout << "\tButtons: " << SDL_JoystickNumButtons(joystick) << std::endl;
  }

  Real spawn_height = 0.0; //-3016.0;
  FPSCamera fps_camera(Vec3(0, spawn_height, 0), Vec3());
  Camera *camera = &fps_camera;
  Camera *view_camera = camera;

  Quanta quanta(quantum_radius);
  QuantaRenderer quanta_renderer(canvas_3d);

  PlayerCommandState player_command_state;

  renderer.setDepthTest(GL_LEQUAL);
  renderer.setCullFace(GL_BACK);

  Real speed = 16.0;
  Real droll = 0.0, dpitch = 0.0, dyaw = 0.0;

  //Vec3 joy_sensitivity(50, 50, 150);
  Vec3 joy_sensitivity(0.8, 0.8, 0.25);
  Real joy_pitch = NAN, joy_yaw = NAN, joy_roll = NAN;

  ScreenShooter screen_shooter(window_width, window_height);

  done = false;
  canvas_3d.bind(shader_3d);
  
  Vec3 light_color(Colors::White), ambient_color(light_color * 0.1);
  uint32_t light_id = canvas_3d.createPointLight(Vec3(0.0, 0.0, 0.0, 1.0), universe_size / 8.0, light_color);
  canvas_3d.setAmbientLight(ambient_color);

  while(!done) {
    frame_start = SDL_GetTicks();
    droll = dpitch = dyaw = 0.0;

    while(SDL_PollEvent(&event)) {
      switch(event.type) {
      case SDL_QUIT:
        done = true;
        break;
      case SDL_KEYDOWN:
      case SDL_KEYUP:
        switch(event.key.keysym.scancode) {
        case SDL_SCANCODE_ESCAPE:
          done = true;
          break;
        case SDL_SCANCODE_PAUSE:
          if(event.type == SDL_KEYDOWN) {
            is_paused = !is_paused;
          }
          break;
        case SDL_SCANCODE_F7:
          if(event.type == SDL_KEYDOWN) {
            if(SDL_GetModState() & KMOD_ALT) {
              screen_shooter.toggleMovie();
            } else {
              screen_shooter.prepForShot();
            }
          }
          break;
        case SDL_SCANCODE_UP:
        case SDL_SCANCODE_W:
          player_command_state.movingForward(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_DOWN:
        case SDL_SCANCODE_S:
          player_command_state.movingBackward(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_LEFT:
        case SDL_SCANCODE_A:
          player_command_state.movingLeft(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_RIGHT:
        case SDL_SCANCODE_D:
          player_command_state.movingRight(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_SPACE:
          player_command_state.movingUp(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_LSHIFT:
          player_command_state.movingDown(event.type == SDL_KEYDOWN);
          break;
        case SDL_SCANCODE_Q:
        case SDL_SCANCODE_PAGEDOWN:
          droll = 1.0 * 2.0 * M_PI / 360.0;
          break;
        case SDL_SCANCODE_E:
        case SDL_SCANCODE_PAGEUP:
          droll = -(1.0 * 2.0 * M_PI / 360.0);
          break;
        case SDL_SCANCODE_R:
          if(event.type == SDL_KEYDOWN) {
            speed *= 2;
            std::cout << "Speed: " << speed << std::endl;
          }
          break;
        case SDL_SCANCODE_F:
          if(event.type == SDL_KEYDOWN) {
            speed *= 0.5;
            std::cout << "Speed: " << speed << std::endl;
          }
          break;
        case SDL_SCANCODE_F1:
          std::cout << "FPS: " << frames << " " << SDL_GetTicks() / 1000.0 << "\t" << frames / ((Real)SDL_GetTicks() / 1000.0) << "\t" << 1.0 / (ms_per_frame / 1000.0) << std::endl;
          break;
        case SDL_SCANCODE_F3:
          break;
        case SDL_SCANCODE_F4:
          break;
        case SDL_SCANCODE_F5:
          if(event.type == SDL_KEYDOWN) {
            if(view_camera == camera) {
              view_camera = new Camera(*camera);
              std::cout << "Camera decoupled" << std::endl;
            } else {
              delete view_camera;
              view_camera = camera;
              std::cout << "Camera coupled" << std::endl;
            }
          }
          break;
        case SDL_SCANCODE_F6:
          if(event.type == SDL_KEYDOWN) {
            if(quanta.swapColor(!quanta.swapColor())) {
              std::cout << "Swapping colors on collision." << std::endl;
            } else {
              std::cout << "Not swapping colors on collision." << std::endl;
            }
          }
          break;
        case SDL_SCANCODE_B:
          camera->moveBy(Vec3(0, 0, -128));
          break;
        case SDL_SCANCODE_0:
          if(event.type == SDL_KEYDOWN) {
            std::cout << "Reoriented the camera" << std::endl;
            camera->lookAt(-Vec3::Z, Vec3::Y);
          }
          break;
        case SDL_SCANCODE_G:
          if(camera == &fps_camera && event.type == SDL_KEYDOWN) {
            std::cout << "Flipped camera upside down." << std::endl;
            fps_camera.setPlane(Matrix::rotateZ(M_PI) * fps_camera.plane());
          } break;
        case SDL_SCANCODE_V:
          if(event.type == SDL_KEYDOWN) {
            if(camera == &fps_camera) {
              Camera *c = new Camera(*camera);
              camera = c;
            } else {
              fps_camera.setPosition(camera->position());
              fps_camera.lookAt(-Vec3::Z, Vec3::Y);
              delete camera;
              camera = &fps_camera;
            }
            view_camera = camera;
            std::cout << "Toggled flight" << std::endl;
          } break;
        case SDL_SCANCODE_F2:
          if(event.type == SDL_KEYDOWN) {
            std::cout << "T:\t" << SDL_GetTicks() << std::endl;
            std::cout << "Camera:" << std::endl;
            std::cout << "  Matrix: " << camera->matrix() << std::endl;
            std::cout << "  Position: " << camera->position() << std::endl;
            std::cout << "  Yaw: " << camera->yaw() << std::endl;
            std::cout << "  Right: " << camera->right() << "\tUp: " << camera->up() << "\tFront: " << camera->forward() << std::endl;
            std::cout << "  Rotation: " << camera->rotationMatrix() << camera->rotationMatrix() * camera->rotationMatrix().invert() << std::endl;
            std::cout << "  Translation: " << camera->translationMatrix() << std::endl;
          }
          break;
        case SDL_SCANCODE_RETURN:
          if(event.type == SDL_KEYDOWN) {
            quanta.push_back(new Quantum(camera->forward() * new_offset * 1.5f + camera->position(), camera->forward() * quantum_speed, universe_size, Colors::color(), quantum_mass));
          }
          break;
        case SDL_SCANCODE_EQUALS:
          if(event.type == SDL_KEYDOWN) {
            quantum_speed += 0.1;
            std::cout << "Quantum speed: " << quantum_speed << std::endl;
          }
          break;
        case SDL_SCANCODE_MINUS:
          if(event.type == SDL_KEYDOWN) {
            quantum_speed -= 0.1;
            std::cout << "Quantum speed: " << quantum_speed << std::endl;
          }
          break;
        case SDL_SCANCODE_U:
          if(event.type == SDL_KEYDOWN) {
            quantum_mass -= 1.0;
            std::cout << "Quantum mass: " << quantum_mass << std::endl;
          }
          break;
        case SDL_SCANCODE_I:
          if(event.type == SDL_KEYDOWN) {
            quantum_mass += 1.0;
            std::cout << "Quantum mass: " << quantum_mass << std::endl;
          }
          break;
        case SDL_SCANCODE_LEFTBRACKET:
          if(event.type == SDL_KEYDOWN) {
            num_quanta -= 1;
            std::cout << "Number of quanta decreased to " << num_quanta << std::endl;
          }
          break;
        case SDL_SCANCODE_RIGHTBRACKET:
          if(event.type == SDL_KEYDOWN) {
            num_quanta += 1;
            std::cout << "Number of quanta increased to " << num_quanta << std::endl;
          }
          break;
        case SDL_SCANCODE_P:
          if(event.type == SDL_KEYDOWN) {
            quantum_forward_speed += 0.1;
            std::cout << "Quantum forward speed: " << quantum_forward_speed << std::endl;
          }
          break;
        case SDL_SCANCODE_O:
          if(event.type == SDL_KEYDOWN) {
            quantum_forward_speed -= 0.1;
            std::cout << "Quantum forward speed: " << quantum_forward_speed << std::endl;
          }
          break;
        case SDL_SCANCODE_APOSTROPHE:
          if(event.type == SDL_KEYDOWN) {
            Vec3 color = Colors::color(generation++);
            for(int i = 0; i < num_quanta; i++) {
              quanta.push_back(new Quantum(camera->forward() * new_offset * 1.5f + camera->position() + Vec3::random(min_position, max_position),
                                       quantum_forward_speed * camera->forward() + quantum_speed * Vec3::random(),
                                       universe_size,
                                       color,
                                       quantum_mass));
            }
          }
          break;
        case SDL_SCANCODE_L:
          if(event.type == SDL_KEYDOWN) {
            Vec3 color = Colors::color(generation++);
            Real d = (max_position - min_position).magnitude();
            Real maxq = powf(num_quanta, 1.0/3.0);
            for(int x = 0; x < maxq; x++) {
              for(int y = 0; y < maxq; y++) {
                for(int z = 0; z < maxq; z++) {
                  quanta.push_back(new Quantum(camera->forward() * new_offset * 1.5f + camera->position() + (Vec3(x, y, z) / maxq * d - d / 2),
                                               quantum_forward_speed * camera->forward() + quantum_speed * Vec3::random(),
                                               universe_size,
                                               color,
                                               quantum_mass));
                }
              }
            }
          }
          break;
        }
        break;
      case SDL_WINDOWEVENT:
        switch(event.window.event) {
        case SDL_WINDOWEVENT_RESIZED:
          window_width = event.window.data1;
          window_height = event.window.data2;
          std::cerr << "Window resized to " << window_width << "x" << window_height << std::endl;
          renderer.setViewport(0, 0, window_width, window_height);
          fb1.resize(window_width, window_height);
          fb2.resize(window_width, window_height);
          scratch_fb.resize(window_width, window_height);
          scaled_fb.resize(window_width, window_height);
          screen_shooter.setWindowSize(window_width, window_height);
          break;
        }
        break;
      case SDL_MOUSEMOTION: {
#ifdef MAC
        int button = SDL_BUTTON_LMASK;
#else
        int button = SDL_BUTTON_RMASK;
#endif /* MAC */
        if(event.motion.state & button) {
          dyaw -= event.motion.xrel * 2.0 * M_PI / 360.0;
          dpitch -= event.motion.yrel * 2.0 * M_PI / 360.0;
          //std::cout << "MouseMotion: " << event.motion.xrel << "\t" << event.motion.yrel << endl;
        }
      } break;
      case SDL_MOUSEBUTTONDOWN:
        //SDL_SetWindowGrab();
        switch(event.button.button) {
          case SDL_BUTTON_LEFT:
            if(event.button.clicks == 1) {
              quanta.push_back(new Quantum(camera->forward() * new_offset * 1.5f + camera->position(), camera->forward() * quantum_speed, universe_size, Colors::color(), quantum_mass));
            }
            break;
          case SDL_BUTTON_RIGHT:
            SDL_SetRelativeMouseMode((SDL_bool)true);
            break;
          default:
            std::cerr << "Unknown button: " << event.button.button << std::endl;
            break;
         }
        break;
      case SDL_MOUSEBUTTONUP:
        switch(event.button.button) {
          case SDL_BUTTON_RIGHT:
            SDL_SetRelativeMouseMode((SDL_bool)false);
            break;
        }
        break;
      case SDL_MOUSEWHEEL:
        if(event.wheel.y > 0) {
          quantum_speed += 0.1;
          std::cout << "Quantum speed: " << quantum_speed << std::endl;
        } else if(event.wheel.y < 0) {
          quantum_speed -= 0.1;
          std::cout << "Quantum speed: " << quantum_speed << std::endl;
        }
        if(event.wheel.x > 0) {
          quantum_mass += 1.0;
          std::cout << "Quantum mass: " << quantum_mass << std::endl;
        } else if(event.wheel.x < 0) {
          quantum_mass -= 1.0;
          std::cout << "Quantum mass: " << quantum_mass << std::endl;
        }
        break;
      case SDL_JOYAXISMOTION:
        //std::cout << "JoyAxisMotion: " << event.jaxis.which << "\t" << (int)event.jaxis.axis << "\t" << event.jaxis.value << std::endl;
        switch(event.jaxis.axis) {
        case XPad::AXIS_LEFT_X:
          if(event.jaxis.value > XPad::AXIS_LEFT_DEAD_ZONE) {
            player_command_state.movingLeft(false);
            player_command_state.movingRight(true);
          } else if(event.jaxis.value < -XPad::AXIS_LEFT_DEAD_ZONE) {
            player_command_state.movingLeft(true);
            player_command_state.movingRight(false);
          } else {
            player_command_state.movingLeft(false);
            player_command_state.movingRight(false);
          }
          break;
        case XPad::AXIS_LEFT_Y:
          if(event.jaxis.value > XPad::AXIS_LEFT_DEAD_ZONE) {
            player_command_state.movingForward(false);
            player_command_state.movingBackward(true);
          } else if(event.jaxis.value < -XPad::AXIS_LEFT_DEAD_ZONE) {
            player_command_state.movingForward(true);
            player_command_state.movingBackward(false);
          } else {
            player_command_state.movingForward(false);
            player_command_state.movingBackward(false);
          }
          break;
        case XPad::AXIS_RIGHT_Y:
          if(rabs(event.jaxis.value) > XPad::AXIS_RIGHT_DEAD_ZONE) {
            joy_pitch = event.jaxis.value * 2.0 * M_PI / (Real)XPad::AXIS_MAX * joy_sensitivity.x();
          } else {
            joy_pitch = NAN;
          }
          break;
        case XPad::AXIS_RIGHT_X:
          if(rabs(event.jaxis.value) > XPad::AXIS_RIGHT_DEAD_ZONE) {
            joy_yaw = event.jaxis.value * 2.0 * M_PI / (Real)XPad::AXIS_MAX * joy_sensitivity.y();
          } else {
            joy_yaw = NAN;
          }
          break;
        case XPad::AXIS_LEFT_TRIGGER:
          if(event.jaxis.value > XPad::AXIS_MIN) {
            joy_roll = -((event.jaxis.value - XPad::AXIS_MIN) * 2.0 * M_PI / (Real)XPad::AXIS_MAX * joy_sensitivity.z());
          } else {
            joy_roll = NAN;
          }
          break;
        case XPad::AXIS_RIGHT_TRIGGER:
          if(event.jaxis.value > XPad::AXIS_MIN) {
            joy_roll = (event.jaxis.value - XPad::AXIS_MIN) * 2.0 * M_PI / (Real)XPad::AXIS_MAX * joy_sensitivity.z();
          } else {
            joy_roll = NAN;
          }
          break;
        }
        break;
      case SDL_JOYBUTTONUP:
      case SDL_JOYBUTTONDOWN:
        switch(event.jbutton.button) {
        case XPad::BUTTON_A:
          player_command_state.movingUp(event.jbutton.state == SDL_PRESSED);
          break;
        case XPad::BUTTON_X:
          player_command_state.movingDown(event.jbutton.state == SDL_PRESSED);
          break;
        case XPad::BUTTON_B:
          if(event.jbutton.state == SDL_PRESSED) {
            speed *= 2.0;
            std::cout << "Speed: " << speed << std::endl;
          }
          break;
        case XPad::BUTTON_Y:
          if(event.jbutton.state == SDL_PRESSED) {
            speed *= 0.5;
            std::cout << "Speed: " << speed << std::endl;
          }
          break;
        case XPad::BUTTON_WHITE:
          if(event.type == SDL_JOYBUTTONDOWN) {
            if(camera == &fps_camera) {
              Camera *c = new Camera(*camera);
              camera = c;
            } else {
              fps_camera.setPosition(camera->position());
              fps_camera.lookAt(-Vec3::Z, Vec3::Y);
              delete camera;
              camera = &fps_camera;
            }
            view_camera = camera;
            std::cout << "Toggled flight" << std::endl;
          } break;
        case XPad::BUTTON_BACK:
          if(event.type == SDL_JOYBUTTONDOWN) {
            done = true;
          }
        }
      case SDL_JOYHATMOTION:
        //std::cout << "JoyHatMotion: " << event.jhat.which << "\t" << (int)event.jhat.hat << "\t" << (int)event.jhat.value << std::endl;
        break;
      default:
        //std::cout << "Unknown event: " << event.type << std::endl;
        break;
      }
    }

    Real sec_per_frame = ms_per_frame / 1000.0;

    if(!isnan(joy_roll)) {
      droll -= joy_roll * sec_per_frame;
    }
    if(!isnan(joy_pitch)) {
      dpitch -= joy_pitch * sec_per_frame;
    }
    if(!isnan(joy_yaw)) {
      dyaw -= joy_yaw * sec_per_frame;
    }

    Vec3 dir = player_command_state.motionVector();
    if(!dir.isNaN()) {
      camera->moveBy(dir * speed * (ms_per_frame / 1000.0));
    }
    camera->rotateBy(Vec3(dpitch, dyaw, droll));

    if(!is_paused) {
      quanta.update(1.0);
    }

    renderer.updateTime(now);
    //renderer.setColorMatrix(Matrix::rotate(Vec3(now / 1000.0, now / 1000.0, now / 1000.0)));

    canvas_3d.bind(shader_3d);
    canvas_3d.pushProjectionMatrix(); {
      fb1.bindFramebuffer();
      renderer.setViewport(window_width * 0.25, 0, window_width * 0.75, window_height);

      light_id = canvas_3d.createPointLight(Vec3(0.0, 0.0, 0.0, 1.0), universe_size / 8.0, light_color);
      canvas_3d.setAmbientLight(ambient_color);

      renderer.clear();
      fb1.clear(1, Vec3(0.5, 0.5, 0.5));
      //front->clear(1, Vec3(0.0, 0.0, 0.0, 1.0));
      canvas_3d.setProjectionMatrix(Matrix::perspectiveProjection(80.0, (Real)(window_width * 0.75) / (Real)window_height, far_plane, near_plane));
      canvas_3d.setCamera(*camera);
      //Vec3 light_pos(Matrix::rotateZ(SDL_GetTicks() * M_PI / 1000.0 / 8.0) * Matrix::rotateY(SDL_GetTicks() * M_PI / 1000.0 / 4.0) * Vec3(16.0, 0.0, 0.0));
      Vec3 light_pos(Vec3(0.0, 0.0, 0.0));
      canvas_3d.moveLight(light_id, light_pos);
      canvas_3d.bindMaterial(GL_FRONT_AND_BACK, Canvas3D::AxisMaterial);
      canvas_3d.renderPoint(light_pos, light_color, 10.0);

      //#ifdef RENDER_ORIGIN
      canvas_3d.pushModelViewMatrix(); {
        canvas_3d.setVelocity(Vec3());
        canvas_3d.renderOriginAxis();
      } canvas_3d.popModelViewMatrix();
      //#endif

#ifdef RENDER_ROTATED_VECTOR
      renderer.bindMaterial(GL_FRONT_AND_BACK, Canvas3D::AxisMaterial);
    
      for(int i = 0; i < 32; i++) {
        float t = 0; SDL_GetTicks() / 1000.0 * 2.0 * M_PI;
        float a = i * 2.0 * M_PI / 32.0;
        Vec3 angles = Vec3(a + t, a + t, a + t);
        //renderer.renderVector(Vec3(), (Matrix::rotate(angles) * Vec3::X).normalize() * 10.0, Colors::Cyan);
        //renderer.renderVector(Vec3(), (Matrix::rotate(angles * Vec3(1.0, 0.0, 1.0, 1.0)) * Vec3::X).normalize() * 10.0, Colors::Magenta);
        canvas_3d.pushModelViewMatrix(); {
          canvas_3d.mulModelViewMatrix(Matrix::rotate(Vec3::Y * t));
          canvas_3d.setVelocity(Vec3());
          canvas_3d.renderVector(Vec3(), (Matrix::rotate(angles) * Vec3::X).normalize() * 10.0, Colors::Magenta);
        } canvas_3d.popModelViewMatrix();
      }
#endif
    
      canvas_3d.pushModelViewMatrix(); {
        quanta_renderer.render(*view_camera, quanta);
        //quanta_renderer.renderVelocities(*view_camera, quanta);
      } canvas_3d.popModelViewMatrix();

    } canvas_3d.popProjectionMatrix();

    fb1.unbindFramebuffer();
    ASSERT_GL_ERROR;

    // post processing
    fb2.bindFramebuffer();
    renderer.setViewport(0, 0, window_width, window_height);
    mblur.render(fb1.colors(), fb1.depth(), fb1.velocity(), fb1.bloom());
    bloom.render(renderer.defaultFramebuffer(), fb2.colors(), fb2.bloom(), 1.0);

    // side panes
    renderer.setViewport(0, 0, window_width, window_height);
    canvas_2d.bind(shader_2d);
    canvas_2d.pushProjectionMatrix(); {
      canvas_2d.pushModelViewMatrix(); {
        canvas_2d.setModelViewMatrix(Matrix::identity());
        canvas_2d.setProjectionMatrix(Matrix::orthographicProjection(0.0, 0.0, 4.0, 4.0, 100.0, -100.0));
        canvas_2d.setVelocity(Vec3());
        canvas_2d.setColor(Colors::White);
        canvas_2d.renderSprite(fb1.colors(), Vec3(0, 0, 0.0), Vec3(0.0, 0.0), Vec3(1.0, 1.0, 1.0), 0.0);
        canvas_2d.pushColorMatrix(); {
          //renderer.mulColorMatrix(Matrix::translation(0.5) * Matrix::scale(0.5));
          //renderer.mulColorMatrix(Matrix::scale(2.0) * Matrix::translation(-0.5));
          canvas_2d.renderSprite(fb1.velocity(), Vec3(0, 1, 0.0), Vec3(0.0, 0.0), Vec3(1.0, 1.0, 1.0), 0.0);
        } canvas_2d.popColorMatrix();
        canvas_2d.renderSprite(scaled_fb.colors(), Vec3(0, 2, 0.0), Vec3(0.0, 0.0), Vec3(1.0, 1.0, 1.0), 0.0);
        canvas_2d.renderSprite(fb2.bloom(), Vec3(0, 3, 0.0), Vec3(0.0, 0.0), Vec3(1.0, 1.0, 1.0), 0.0);
      } canvas_2d.popModelViewMatrix();
    } canvas_2d.popProjectionMatrix();

    renderer.swap();
    ASSERT_GL_ERROR;

    screen_shooter.takeScreenShot();

    frames++;
    ms_per_frame = SDL_GetTicks() - frame_start;
  }

  return 0;
}
