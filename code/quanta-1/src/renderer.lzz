#hdr
#include <map>
#include "renderer/material.h"
#include "renderer/texture.h"
#include "renderer/camera.h"
#include "renderer/uniform_matrix_stack.h"
#include "renderer/square_mesh.h"
#end

#src
#include <SDL2/SDL.h>
#include "gl.h"
#include "real.h"
#include <assert.h>
#end

class RendererError
{
private:
  const char *_context, *_msg;
  std::string _what;

public:
  RendererError(const char *context, const char *msg)
    : _context(context), _msg(msg), _what(context)
  {
    _what += ": ";
    _what += _msg;
  }

  const std::string &what() const { return _what; }
};

class Renderer
{
public:
  typedef std::map<const Texture *, GLuint> TextureIdMap;
private:
  SDL_GLContext _gl_context;
  SDL_Window *_window;
  TextureIdMap _texture_handles;
  GLuint _shader_in_position, _shader_in_color, _shader_in_texture, _shader_uniform_color, _shader_uniform_texture, _shader_in_time, _shader_uniform_light0_position, _shader_uniform_light0_intensity, _shader_uniform_light0_color, _shader_uniform_light0_specular, _shader_uniform_ambient_light, _shader_uniform_forward, _shader_uniform_camera;
  SquareMesh *_quad;
  UniformMatrixStack _modelview, _projection, _texture, _color;
  Vec3 _uniform_color;

public:
  Renderer(SDL_Window *window)
    : _window(window), _uniform_color(Colors::White)
  {
    //SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

    // use OpenGL 3.3+
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);

    _gl_context = SDL_GL_CreateContext(_window);
    if(!_gl_context) {
      throw RendererError("OpenGL context", SDL_GetError());
    }

    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if(err != GLEW_OK) {
      throw RendererError("OpenGL init failed", (const char *)glewGetErrorString(err));
    }

    ASSERT_GL_ERROR;

    _quad = new SquareMesh(*this);

    blankDefaultTexture();
  }

  virtual ~Renderer()
  {
    for(TextureIdMap::iterator it = _texture_handles.begin(); it != _texture_handles.end(); it++) {
      glDeleteTextures(1, &it->second);
    }

    delete _quad;
    
    SDL_GL_DeleteContext(_gl_context);
  }

  void swap()
  {
    SDL_GL_SwapWindow(_window);
    ASSERT_GL_ERROR;
  }

  void setClearColor(const Vec3 &c)
  {
    glClearColor(c.x(), c.y(), c.z(), c.w());
  }

  void clear()
  {
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  }

  void blankDefaultTexture()
  {
    unbindTexture();
    Vec3 p[4] = { Colors::White, Colors::White, Colors::White, Colors::White };
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 2, 2, 0, GL_RGBA, GL_REAL, p);
    ASSERT_GL_ERROR;
  }
  
  void bindMaterial(GLenum face, const Material &m)
  {
    glMateriali(face, GL_SHININESS, m.shininess());
    glMaterialrv(face, GL_SPECULAR, m.specular());
    glMaterialrv(face, GL_EMISSION, m.emission());
    glMaterialrv(face, GL_AMBIENT, m.ambient());
    glMaterialrv(face, GL_DIFFUSE, m.diffuse());
  }

  void unbindMaterial(GLenum face)
  {
    glMateriali(face, GL_SHININESS, 127);
    glMaterialrv(face, GL_SPECULAR, Colors::White);
    glMaterialrv(face, GL_EMISSION, Colors::Black);
    glMaterialrv(face, GL_AMBIENT, Colors::Black);
    glMaterialrv(face, GL_DIFFUSE, Colors::White);
  }

  unsigned int findTextureHandle(const Texture &tex)
  {
    return _texture_handles[&tex];
  }

  void bindTexture(const Texture &tex)
  {
    glActiveTexture(GL_TEXTURE0);
    glUniform1i(_shader_uniform_texture, 0);
    glBindTexture(GL_TEXTURE_2D, findTextureHandle(tex));
    ASSERT_GL_ERROR;
  }

  void unbindTexture()
  {
    glBindTexture(GL_TEXTURE_2D, 0);
    ASSERT_GL_ERROR;
  }

  bool loadTexture(Texture &tex)
  {
    return loadTexture(tex, 0, 4);
  }
  
  bool loadTexture(Texture &tex, GLuint tex_unit, int num_mipmaps = 4)
  {
    GLuint tex_id;
    GLenum mode = GL_RGBA;

    assert(tex_unit < GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);

    if(!tex.loaded()) {
      if(!tex.load()) {
        return false;
      }
    }

    int bpp;
    Uint32 rmask, gmask, bmask, amask;
    SDL_PixelFormatEnumToMasks(SDL_PIXELFORMAT_ABGR8888, &bpp, &rmask, &gmask, &bmask, &amask);
    SDL_Surface *surf = SDL_CreateRGBSurface(0, tex.width(), tex.height(), bpp, rmask, gmask, bmask, amask);
    if(surf == NULL) {
      return false;
    }

    SDL_SetSurfaceAlphaMod(surf, 0xFF);
    SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
    SDL_BlitSurface(tex.surface(), NULL, surf, NULL);

    switch(surf->format->BytesPerPixel) {
      case 3:
        mode = GL_RGB;
        break;
      case 4:
        mode = GL_RGBA;
        break;
      default:
        std::cerr << "Unknown mode in " << tex.path() << "\t" << (int)surf->format->BytesPerPixel << std::endl;
        return false;
    }

    //glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    //glPixelStorei(GL_UNPACK_ROW_LENGTH, surf->w);
    //ASSERT_GL_ERROR;
    glGenTextures(1, &tex_id);
    ASSERT_GL_ERROR;
    glBindTexture(GL_TEXTURE_2D, tex_id);
    ASSERT_GL_ERROR;
    glActiveTexture(GL_TEXTURE0 + tex_unit);
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, tex.repeatsX() ? GL_REPEAT : GL_CLAMP_TO_BORDER);
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tex.repeatsY() ? GL_REPEAT : GL_CLAMP_TO_BORDER);
    ASSERT_GL_ERROR;
    glTexImage2D(GL_TEXTURE_2D, 0, mode, surf->w, surf->h, 0, mode, GL_UNSIGNED_BYTE, surf->pixels);
    ASSERT_GL_ERROR;
    glGenerateMipmap(GL_TEXTURE_2D);
    ASSERT_GL_ERROR;

    glBindTexture(GL_TEXTURE_2D, 0);
    ASSERT_GL_ERROR;
    
    _texture_handles[&tex] = tex_id;

    SDL_FreeSurface(surf);

    return true;
  }

  void useProgram(GLuint prog_id)
  {
    glUseProgram(prog_id);
    bindUniforms(prog_id);
    setColor(_uniform_color);
  }

  void bindUniforms(GLuint prog_id)
  {
    _shader_in_position = glGetAttribLocation(prog_id, "inPosition");
    _shader_in_color = glGetAttribLocation(prog_id, "inColor");
    _shader_in_texture = glGetAttribLocation(prog_id, "inTexture");
    _shader_in_time = glGetAttribLocation(prog_id, "inTime");

    _shader_uniform_color = glGetUniformLocation(prog_id, "uColor");
    _shader_uniform_texture = glGetUniformLocation(prog_id, "tex");
    _shader_uniform_light0_position = glGetUniformLocation(prog_id, "uLight0Position");
    _shader_uniform_light0_intensity = glGetUniformLocation(prog_id, "uLight0Intensity");
    _shader_uniform_light0_color = glGetUniformLocation(prog_id, "uLight0Color");
    _shader_uniform_light0_specular = glGetUniformLocation(prog_id, "uLight0Specular");
    _shader_uniform_ambient_light = glGetUniformLocation(prog_id, "uAmbientLight");
    _shader_uniform_forward = glGetUniformLocation(prog_id, "uForward");
    _shader_uniform_camera = glGetUniformLocation(prog_id, "uCamera");

    _modelview.setLocation(glGetUniformLocation(prog_id, "mModelView"));
    _projection.setLocation(glGetUniformLocation(prog_id, "mProjection"));
    _texture.setLocation(glGetUniformLocation(prog_id, "mTexture"));
    _color.setLocation(glGetUniformLocation(prog_id, "mColor"));
    
    ASSERT_GL_ERROR;
  }

  GLuint shaderInPositionAttrib() const
  {
    return _shader_in_position;
  }

  GLuint shaderInColorAttrib() const
  {
    return _shader_in_color;
  }

  GLuint shaderInTextureAttrib() const
  {
    return _shader_in_texture;
  }

  void updateTime(GLuint t)
  {
    glUniform1i(_shader_in_time, t);
  }

  void setProjectionMatrix(const Matrix &m)
  {
    _projection.load(m);
  }

  void mulProjectionMatrix(const Matrix &m)
  {
    _projection.mul(m);
  }

  void setModelViewMatrix(const Matrix &m)
  {
    _modelview.load(m);
  }

  void mulModelViewMatrix(const Matrix &m)
  {
    _modelview.mul(m);
  }

  void pushModelViewMatrix()
  {
    _modelview.push();
  }

  void popModelViewMatrix()
  {
    _modelview.pop();
  }

  void setTextureMatrix(const Matrix &m)
  {
    _texture.load(m);
  }

  void setColor(const Vec3 &c)
  {
    _uniform_color = c;
    glUniform4rv(_shader_uniform_color, 1, c);
    ASSERT_GL_ERROR;
  }
  
  void setColorMatrix(const Matrix &m)
  {
    _color.load(m);
  }

  void pushColorMatrix()
  {
    _color.push();
  }

  void popColorMatrix()
  {
    _color.pop();
  }

  void mulColorMatrix(const Matrix &m)
  {
    _color.mul(m);
  }

  void setCamera(const Camera &camera)
  {
    glUniform3rv(_shader_uniform_forward, 1, camera.forward());
    glUniform3rv(_shader_uniform_camera, 1, camera.position());
    setModelViewMatrix(camera.matrix().invert());
  }
  
  void renderSprite(const Texture &tex, const Vec3 &position, const Vec3 &origin, const Vec3 &size, const Real &angle)
  {
    _modelview.push();
    _modelview.mul(Matrix::translation(-origin) * Matrix::scale(size) * Matrix::rotateZ(angle) * Matrix::translation(position));
    bindTexture(tex);
    ASSERT_GL_ERROR;
    _quad->bind();
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    ASSERT_GL_ERROR;
    _quad->unbind();
    _modelview.pop();
    unbindTexture();
  }

 void renderCameraAxis(const Camera &camera)
  {
    glBegin(GL_LINES);
    glColor3rv(Colors::Red);
    glVertex3rv(camera.position() + camera.right() * 1024);
    glVertex3rv(camera.position());
    glColor3rv(Colors::Green);
    glVertex3rv(camera.position() + camera.up() * 1024);
    glVertex3rv(camera.position());
    glColor3rv(Colors::Blue);
    glVertex3rv(camera.position() + camera.forward() * 1024);
    glVertex3rv(camera.position());


    glColor3rv(Colors::Yellow);
    glVertex3rv(camera.position() + Vec3(1, 0, 0) * 1024);
    glVertex3rv(camera.position());
    glColor3rv(Colors::Cyan);
    glVertex3rv(camera.position() + Vec3(0, 1, 0) * 1024);
    glVertex3rv(camera.position());
    glColor3rv(Colors::Magenta);
    glVertex3rv(camera.position() + Vec3(0, 0, 1) * 1024);
    glVertex3rv(camera.position());

    glEnd();
  }

  void renderOriginAxis()
  {
    glBegin(GL_LINES);
    glColor3rv(Colors::Red);
    glVertex3r(1024, 0, 0);
    glVertex3r(0, 0, 0);
    glColor3rv(Colors::Green);
    glVertex3r(0, 1024, 0);
    glVertex3r(0, 0, 0);
    glColor3rv(Colors::Blue);
    glVertex3r(0, 0, 1024);
    glVertex3r(0, 0, 0);
    glEnd();
  }

  void renderAxis(const Vec3 &origin, const Vec3 &right = Vec3::X, const Vec3 &up = Vec3::Y)
  {
    glPushMatrix(); {
      glMultMatrixr(Matrix::translation(origin));
      glMultMatrixr(Matrix::lookAt(up.cross(right), up));
      // todo rotate to fit right

      renderOriginAxis();

    } glPopMatrix();
  }

  void renderVector(const Vec3 &origin, const Vec3 &v, const Vec3 &color = Colors::White)
  {
    glLineWidth(16.0);
    glColor3rv(color);
    glBegin(GL_LINES);
    glVertex3rv(origin);
    glVertex3rv(origin + v);
    glEnd();
  }

  void renderNormal(const Vec3 &origin, const Vec3 &normal, const Vec3 &color = Colors::Green)
  {
    renderVector(origin, normal * 512.0, color);
  }

  void renderPole(const Camera &cam, const Vec3 &position, Real value, const Vec3 &color)
  {
    renderVector(position, Vec3(0, 1, 0) * value, color);
  }

  void renderPoint(const Vec3 &position, const Vec3 &color = Colors::White)
  {
    glBegin(GL_POINTS);
    glColor4rv(color);
    glVertex3rv(position);
    glEnd();
  }

  void renderLine(const Vec3 &a, const Vec3 &b, const Vec3 &color = Colors::White)
  {
    glLineWidth(4);
    glBegin(GL_LINES);
    glColor3rv(color);
    glVertex3rv(a);
    glVertex3rv(b);
    glEnd();
  }

  void setViewport(int top, int left, int width, int height)
  {
    glViewport(top, left, width, height);
  }
  
  uint32_t createPointLight(const Vec3 &position, Real attenuation, const Vec3 &color, const Vec3 &specular)
  {
    moveLight(0, position);
    glUniform1r(_shader_uniform_light0_intensity, attenuation);
    ASSERT_GL_ERROR;
    glUniform3rv(_shader_uniform_light0_color, 1, color);
    ASSERT_GL_ERROR;
    glUniform4rv(_shader_uniform_light0_specular, 1, specular);
    ASSERT_GL_ERROR;
    return 0;
    // glLightr(GL_LIGHT0, GL_CONSTANT_ATTENUATION, attenuation);
    // glLightrv(GL_LIGHT0, GL_DIFFUSE, color);
    // glLightrv(GL_LIGHT0, GL_SPECULAR, specular);

    // glEnable(GL_LIGHT0);
  }

  void setAmbientLight(const Vec3 &color)
  {
    glUniform3rv(_shader_uniform_ambient_light, 1, color);
    //glLightrv(GL_LIGHT0, GL_AMBIENT, color);
  }

  void moveLight(uint32_t id, const Vec3 &position)
  {
    glUniform4rv(_shader_uniform_light0_position, 1, _modelview.top() * position);
    ASSERT_GL_ERROR;
    //glLightrv(GL_LIGHT0, GL_POSITION, position);
  }    
};
