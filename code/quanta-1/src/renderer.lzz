#hdr
#include <map>
#include "renderer/material.h"
#include "renderer/texture.h"
#include "renderer/camera.h"
#include "renderer/uniform_matrix_stack.h"
#include "renderer/square_mesh.h"
#include "renderer/line_mesh.h"
#end

#src
#include <SDL2/SDL.h>
#include "gl.h"
#include "real.h"
#include "math-fun.h"
#include <assert.h>
#end

class RendererError
{
private:
  const char *_context, *_msg;
  std::string _what;

public:
  RendererError(const char *context, const char *msg)
    : _context(context), _msg(msg), _what(context)
  {
    _what += ": ";
    _what += _msg;
  }

  const std::string &what() const { return _what; }
};

class Renderer
{
public:
  typedef std::map<const Texture *, GLuint> TextureIdMap;
private:
  SDL_GLContext _gl_context;
  SDL_Window *_window;
  TextureIdMap _texture_handles;
  GLuint _shader_in_position, _shader_in_color, _shader_in_texture, _shader_uniform_color, _shader_uniform_texture, _shader_in_time, _shader_uniform_light0_position, _shader_uniform_light0_intensity, _shader_uniform_light0_color, _shader_uniform_ambient_light, _shader_uniform_forward, _shader_uniform_camera;
  GLuint _shader_uniform_material_shine, _shader_uniform_material_specular, _shader_uniform_material_diffuse, _shader_uniform_material_ambient, _shader_uniform_material_emission;
  SquareMesh *_quad;
  LineMesh *_line;
  UniformMatrixStack _modelview, _projection, _texture, _color;
  Vec3 _uniform_color;
  Material _material;

public:
  static const Material AxisMaterial = Material(Colors::White, Colors::White, 0.0, Colors::White, Colors::White);
  
  Renderer(SDL_Window *window)
    : _window(window), _uniform_color(Colors::White)
  {
    //SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

    // use OpenGL 3.3+
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    //SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);

    _gl_context = SDL_GL_CreateContext(_window);
    if(!_gl_context) {
      throw RendererError("OpenGL context", SDL_GetError());
    }

    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if(err != GLEW_OK) {
      throw RendererError("OpenGL init failed", (const char *)glewGetErrorString(err));
    }

    ASSERT_GL_ERROR;

    _quad = new SquareMesh(*this);
    _line = new LineMesh(*this);
    
    blankDefaultTexture();
    bindMaterial(GL_FRONT_AND_BACK, Material::Default);
  }

  virtual ~Renderer()
  {
    for(TextureIdMap::iterator it = _texture_handles.begin(); it != _texture_handles.end(); it++) {
      glDeleteTextures(1, &it->second);
    }

    delete _quad;
    delete _line;
    
    SDL_GL_DeleteContext(_gl_context);
  }

  void swap()
  {
    SDL_GL_SwapWindow(_window);
    ASSERT_GL_ERROR;
  }

  void setClearColor(const Vec3 &c)
  {
    glClearColor(c.x(), c.y(), c.z(), c.w());
  }

  void clear()
  {
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  }

  void blankDefaultTexture()
  {
    unbindTexture();
    Vec3 p[4] = { Colors::White, Colors::White, Colors::White, Colors::White };
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 2, 2, 0, GL_RGBA, GL_REAL, p);
    ASSERT_GL_ERROR;
  }
  
  void bindMaterial(GLenum face, const Material &m)
  {
    if(face == GL_FRONT_AND_BACK) {
      bindMaterial(GL_FRONT, m);
      bindMaterial(GL_BACK, m);
    } else {
      _material = m; // TODO detect if useProgram was called
      glUniform1r(_shader_uniform_material_shine, m.shininess());
      glUniform4rv(_shader_uniform_material_specular, 1, m.specular());
      glUniform4rv(_shader_uniform_material_emission, 1, m.emission());
      glUniform4rv(_shader_uniform_material_ambient, 1, m.ambient());
      glUniform4rv(_shader_uniform_material_diffuse, 1, m.diffuse());
    }
  }

  void unbindMaterial(GLenum face)
  {
    bindMaterial(face, Material::Default);
  }

  unsigned int findTextureHandle(const Texture &tex)
  {
    return _texture_handles[&tex];
  }

  void bindTexture(const Texture &tex)
  {
    glActiveTexture(GL_TEXTURE0);
    glUniform1i(_shader_uniform_texture, 0);
    glBindTexture(GL_TEXTURE_2D, findTextureHandle(tex));
    ASSERT_GL_ERROR;
  }

  void unbindTexture()
  {
    glBindTexture(GL_TEXTURE_2D, 0);
    ASSERT_GL_ERROR;
  }

  bool loadTexture(Texture &tex)
  {
    return loadTexture(tex, 0, 4);
  }
  
  bool loadTexture(Texture &tex, GLuint tex_unit, int num_mipmaps = 4)
  {
    GLuint tex_id;
    GLenum mode = GL_RGBA;

    assert(tex_unit < GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);

    if(!tex.loaded()) {
      if(!tex.load()) {
        return false;
      }
    }

    int bpp;
    Uint32 rmask, gmask, bmask, amask;
    SDL_PixelFormatEnumToMasks(SDL_PIXELFORMAT_ABGR8888, &bpp, &rmask, &gmask, &bmask, &amask);
    SDL_Surface *surf = SDL_CreateRGBSurface(0, tex.width(), tex.height(), bpp, rmask, gmask, bmask, amask);
    if(surf == NULL) {
      return false;
    }

    SDL_SetSurfaceAlphaMod(surf, 0xFF);
    SDL_SetSurfaceBlendMode(surf, SDL_BLENDMODE_NONE);
    SDL_BlitSurface(tex.surface(), NULL, surf, NULL);

    switch(surf->format->BytesPerPixel) {
      case 3:
        mode = GL_RGB;
        break;
      case 4:
        mode = GL_RGBA;
        break;
      default:
        std::cerr << "Unknown mode in " << tex.path() << "\t" << (int)surf->format->BytesPerPixel << std::endl;
        return false;
    }

    //glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    //glPixelStorei(GL_UNPACK_ROW_LENGTH, surf->w);
    //ASSERT_GL_ERROR;
    glGenTextures(1, &tex_id);
    ASSERT_GL_ERROR;
    glBindTexture(GL_TEXTURE_2D, tex_id);
    ASSERT_GL_ERROR;
    glActiveTexture(GL_TEXTURE0 + tex_unit);
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, tex.repeatsX() ? GL_REPEAT : GL_CLAMP_TO_BORDER);
    ASSERT_GL_ERROR;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tex.repeatsY() ? GL_REPEAT : GL_CLAMP_TO_BORDER);
    ASSERT_GL_ERROR;
    glTexImage2D(GL_TEXTURE_2D, 0, mode, surf->w, surf->h, 0, mode, GL_UNSIGNED_BYTE, surf->pixels);
    ASSERT_GL_ERROR;
    glGenerateMipmap(GL_TEXTURE_2D);
    ASSERT_GL_ERROR;

    glBindTexture(GL_TEXTURE_2D, 0);
    ASSERT_GL_ERROR;
    
    _texture_handles[&tex] = tex_id;

    SDL_FreeSurface(surf);

    return true;
  }

  void useProgram(GLuint prog_id)
  {
    glUseProgram(prog_id);
    bindUniforms(prog_id);
    setColor(_uniform_color);
    bindMaterial(GL_FRONT_AND_BACK, _material);
  }

  void bindUniforms(GLuint prog_id)
  {
    _shader_in_position = glGetAttribLocation(prog_id, "inPosition");
    _shader_in_color = glGetAttribLocation(prog_id, "inColor");
    _shader_in_texture = glGetAttribLocation(prog_id, "inTexture");
    _shader_in_time = glGetAttribLocation(prog_id, "inTime");

    _shader_uniform_color = glGetUniformLocation(prog_id, "uColor");
    _shader_uniform_texture = glGetUniformLocation(prog_id, "tex");
    _shader_uniform_light0_position = glGetUniformLocation(prog_id, "uLight.position");
    _shader_uniform_light0_intensity = glGetUniformLocation(prog_id, "uLight.intensity");
    _shader_uniform_light0_color = glGetUniformLocation(prog_id, "uLight.color");
    _shader_uniform_ambient_light = glGetUniformLocation(prog_id, "uAmbientLight");
    _shader_uniform_forward = glGetUniformLocation(prog_id, "uForward");
    _shader_uniform_camera = glGetUniformLocation(prog_id, "uCamera");

    _shader_uniform_material_shine = glGetUniformLocation(prog_id, "uMaterial.shine");
    _shader_uniform_material_specular = glGetUniformLocation(prog_id, "uMaterial.specular");
    _shader_uniform_material_diffuse = glGetUniformLocation(prog_id, "uMaterial.diffuse");
    _shader_uniform_material_ambient = glGetUniformLocation(prog_id, "uMaterial.ambient");
    _shader_uniform_material_emission = glGetUniformLocation(prog_id, "uMaterial.emission");

    _modelview.setLocation(glGetUniformLocation(prog_id, "mModelView"));
    _projection.setLocation(glGetUniformLocation(prog_id, "mProjection"));
    _texture.setLocation(glGetUniformLocation(prog_id, "mTexture"));
    _color.setLocation(glGetUniformLocation(prog_id, "mColor"));
    
    ASSERT_GL_ERROR;
  }

  GLuint shaderInPositionAttrib() const
  {
    return _shader_in_position;
  }

  GLuint shaderInColorAttrib() const
  {
    return _shader_in_color;
  }

  GLuint shaderInTextureAttrib() const
  {
    return _shader_in_texture;
  }

  void updateTime(GLuint t)
  {
    glUniform1i(_shader_in_time, t);
  }

  void setProjectionMatrix(const Matrix &m)
  {
    _projection.load(m);
  }

  void mulProjectionMatrix(const Matrix &m)
  {
    _projection.mul(m);
  }

  void setModelViewMatrix(const Matrix &m)
  {
    _modelview.load(m);
  }

  void mulModelViewMatrix(const Matrix &m)
  {
    _modelview.mul(m);
  }

  void pushModelViewMatrix()
  {
    _modelview.push();
  }

  void popModelViewMatrix()
  {
    _modelview.pop();
  }

  void setTextureMatrix(const Matrix &m)
  {
    _texture.load(m);
  }

  void setColor(const Vec3 &c)
  {
    _uniform_color = c;
    glUniform4rv(_shader_uniform_color, 1, c);
    ASSERT_GL_ERROR;
  }
  
  void setColorMatrix(const Matrix &m)
  {
    _color.load(m);
  }

  void pushColorMatrix()
  {
    _color.push();
  }

  void popColorMatrix()
  {
    _color.pop();
  }

  void mulColorMatrix(const Matrix &m)
  {
    _color.mul(m);
  }

  void setCamera(const Camera &camera)
  {
    glUniform3rv(_shader_uniform_forward, 1, camera.forward());
    glUniform3rv(_shader_uniform_camera, 1, camera.position());
    setModelViewMatrix(camera.matrix().invert());
  }
  
  void renderSprite(const Texture &tex, const Vec3 &position, const Vec3 &origin, const Vec3 &size, const Real &angle)
  {
    _modelview.push();
    _modelview.mul(Matrix::translation(-origin) * Matrix::scale(size) * Matrix::rotateZ(angle) * Matrix::translation(position));
    bindTexture(tex);
    ASSERT_GL_ERROR;
    _quad->bind();
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    ASSERT_GL_ERROR;
    _quad->unbind();
    _modelview.pop();
    unbindTexture();
  }

 void renderCameraAxis(const Camera &camera)
  {
    renderAxis(camera.position(), camera.right(), camera.up());
    pushColorMatrix(); {
      mulColorMatrix(Matrix::rotate(Vec3(M_PI / 4.0, M_PI / 4.0, M_PI / 4.0)));
      renderAxis(camera.position(), Vec3::X, Vec3::Y);
    } popColorMatrix();
  }

  void renderOriginAxis()
  {
    bindMaterial(GL_FRONT_AND_BACK, AxisMaterial);
    renderVector(Vec3(), Vec3::X, Colors::Red);
    renderVector(Vec3(), Vec3::Y, Colors::Green);
    renderVector(Vec3(), Vec3::Z, Colors::Blue);
    unbindMaterial(GL_FRONT_AND_BACK);
  }

  void renderAxis(const Vec3 &origin, const Vec3 &right = Vec3::X, const Vec3 &up = Vec3::Y)
  {
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::lookAt(up.cross(right), up) * Matrix::translation(origin));
      renderOriginAxis();
    } popModelViewMatrix();
  }

  void renderVector(const Vec3 &origin, const Vec3 &v, const Vec3 &color = Colors::White)
  {
    ASSERT_GL_ERROR;
    glLineWidth(4.0);
    glPointSize(10.0);
    ASSERT_GL_ERROR;
    setColor(color);
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::scale(v * Vec3(1.0, 1.0, 1.0, 0.0) + Vec3::W) * Matrix::translation(origin));
      _line->bind();
      glDrawArrays(GL_LINES, 0, 2);
      _line->unbind();
    } popModelViewMatrix();
    ASSERT_GL_ERROR;
  }

  void renderNormal(const Vec3 &origin, const Vec3 &normal, const Vec3 &color = Colors::Green)
  {
    bindMaterial(GL_FRONT_AND_BACK, AxisMaterial);
    renderVector(origin, normal * 512.0, color);
  }

  void renderPole(const Camera &cam, const Vec3 &position, Real value, const Vec3 &color)
  {
    bindMaterial(GL_FRONT_AND_BACK, AxisMaterial);
    renderVector(position, Vec3(0, 1, 0) * value, color);
  }

  void renderPoint(const Vec3 &position, const Vec3 &color = Colors::White, Real diameter = 1.0)
  {
    ASSERT_GL_ERROR;
    glPointSize(clamp<Real>(diameter, 10.0));
    setColor(color);
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::translation(position));
      _line->bind();
      glDrawArrays(GL_POINTS, 0, 1);
      _line->unbind();
    } popModelViewMatrix();
    ASSERT_GL_ERROR;
  }

  void renderLine(const Vec3 &a, const Vec3 &b, const Vec3 &color = Colors::White)
  {
    renderVector(a, b - a, color);
  }

  void setViewport(int top, int left, int width, int height)
  {
    glViewport(top, left, width, height);
  }
  
  uint32_t createPointLight(const Vec3 &position, Real attenuation, const Vec3 &color)
  {
    moveLight(0, position);
    glUniform1r(_shader_uniform_light0_intensity, attenuation);
    ASSERT_GL_ERROR;
    glUniform3rv(_shader_uniform_light0_color, 1, color);
    ASSERT_GL_ERROR;
    return 0;
  }

  void setAmbientLight(const Vec3 &color)
  {
    glUniform3rv(_shader_uniform_ambient_light, 1, color);
  }

  void moveLight(uint32_t id, const Vec3 &position)
  {
    glUniform4rv(_shader_uniform_light0_position, 1, _modelview.top() * position);
    ASSERT_GL_ERROR;
  }    
};
