#hdr
#include <map>
#include "renderer/texture.h"
#include "renderer/camera.h"
#include "renderer/uniform_matrix_stack.h"
#include "renderer/gl3/framebuffer.h"
#end

#src
#include <SDL2/SDL.h>
#include "gl.h"
#include "real.h"
#include "math-fun.h"
#include <assert.h>
#end

class RendererError
{
private:
  const char *_context, *_msg;
  std::string _what;

public:
  RendererError(const char *context, const char *msg)
    : _context(context), _msg(msg), _what(context)
  {
    _what += ": ";
    _what += _msg;
  }

  const std::string &what() const { return _what; }
};

class Renderer
{
public:

private:
  SDL_GLContext _gl_context;
  SDL_Window *_window;
  GLuint _shader_uniform_time;
  GLuint _shader_uniform_fps, _shader_uniform_target_fps;
  Texture *_default_texture;
  Real _last_frame_time, _target_fps;

  static GL3::Framebuffer DefaultFramebuffer = GL3::Framebuffer(0);
  
public:
  Renderer(SDL_Window *window)
    : _window(window), _target_fps(60.0)
  {
    //SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

    // use OpenGL 3.3+
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    //SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 16);

    _gl_context = SDL_GL_CreateContext(_window);
    if(!_gl_context) {
      throw RendererError("OpenGL context", SDL_GetError());
    }

    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if(err != GLEW_OK) {
      throw RendererError("OpenGL init failed", (const char *)glewGetErrorString(err));
    }

    ASSERT_GL_ERROR;

    _default_texture = new Texture();
    
    _last_frame_time = currentTime();
  }

  virtual ~Renderer()
  {
    delete _default_texture;
    
    SDL_GL_DeleteContext(_gl_context);
  }

  void swap()
  {
    SDL_GL_SwapWindow(_window);
    ASSERT_GL_ERROR;
    updateFPS();
  }

  void setClearColor(const Vec3 &c)
  {
    glClearColor(c.x(), c.y(), c.z(), c.w());
  }

  void clear()
  {
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
  }

  void setDepthTest(GLenum f)
  {
    if(f != GL_FALSE) {
      glEnable(GL_DEPTH_TEST);
      glDepthFunc(GL_LEQUAL);
    } else {
      glDisable(GL_DEPTH_TEST);
    }
  }

  void setCullFace(GLenum face)
  {
    if(face != GL_FALSE) {
      glEnable(GL_CULL_FACE);
      glCullFace(face);
    } else {
      glDisable(GL_CULL_FACE);
    }
  }

  void unbindTexture()
  {
    _default_texture->bind();
  }

  void useProgram(GLuint prog_id)
  {
    glUseProgram(prog_id);
    bindUniforms(prog_id);
    ASSERT_GL_ERROR;
  }

  void bindUniforms(GLuint prog_id)
  {
    _shader_uniform_time = glGetAttribLocation(prog_id, "uTime");
    _shader_uniform_fps = glGetUniformLocation(prog_id, "uFPS");
    _shader_uniform_target_fps = glGetUniformLocation(prog_id, "uTargetFPS");

    updateFPS();
    
    ASSERT_GL_ERROR;
  }

  void updateTime(GLuint t)
  {
    glUniform1i(_shader_uniform_time, t);
  }

  GL3::Framebuffer &defaultFramebuffer()
  {
    return DefaultFramebuffer;
  }

  void setViewport(int top, int left, int width, int height)
  {
    glViewport(top, left, width, height);
  }
  
  Real currentTime() const { return SDL_GetTicks() / 1000.0; }

  void updateFPS()
  {
    Real now = currentTime();
    Real fps = 1.0 / (now - _last_frame_time);
    if(fps == INFINITY) fps = _target_fps;
    _last_frame_time = now;
    glUniform1r(_shader_uniform_fps, fps);
    glUniform1r(_shader_uniform_target_fps, _target_fps);
    ASSERT_GL_ERROR;
  }
};
