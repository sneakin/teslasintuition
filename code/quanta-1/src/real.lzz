#hdr
#include <cmath>
#include "gl.h"

#ifdef CHEAPER_MATH
typedef int Integer;
typedef float Real;

#define GL_REAL GL_FLOAT

#define ator atof

#define fmodr fmodf
#define acosr acosf
#define floorr floorf
#define ceilr ceilf
#define modfr modff
#define atan2r atan2f
#define sqrtr sqrtf
#define rabs fabs

#define glVertex3r glVertex3f
#define glVertex3rv glVertex3fv
#define glNormal3rv glNormal3fv
#define glLoadMatrixr glLoadMatrixf
#define glMultMatrixr glMultMatrixf
#define glScaler glScalef
#define glTranslater glTranslatef
#define glColor3rv glColor3fv
#define glColor4rv glColor4fv
#define glLightrv glLightfv
#define glLightr glLightf
#define glMaterialrv glMaterialfv
#define glFogrv glFogfv
#define glClearBufferrv glClearBufferfv

#define glUniform1r glUniform1f
#define glUniform3rv glUniform3fv
#define glUniform4rv glUniform4fv
#define glUniformMatrix4rv glUniformMatrix4fv

#else
typedef long Integer;
typedef double Real;

#define GL_REAL GL_DOUBLE

#define ator atof

#define fmodr fmod
#define acosr acos
#define floorr ::floor
#define ceilr ceil
#define modfr modf
#define atan2r atan2
#define sqrtr sqrt
#define rabs fabs

#define glVertex3r glVertex3d
#define glVertex3rv glVertex3dv
#define glNormal3rv glNormal3dv
#define glLoadMatrixr glLoadMatrixd
#define glMultMatrixr glMultMatrixd
#define glScaler glScaled
#define glTranslater glTranslated
#define glColor3rv glColor3dv
#define glColor4rv glColor4dv
#define glLightr glLightf

inline void glLightrv(GLenum light, GLenum a, const Real v[4])
{
  float fv[4] = { (float)v[0], (float)v[1], (float)v[2], (float)v[3] };
  glLightfv(light, a, fv);
}

inline void glFogrv(GLenum name, const Real v[4])
{
  float fv[4] = { (float)v[0], (float)v[1], (float)v[2], (float)v[3] };
  glFogfv(name, fv);
}

inline void glMaterialrv(GLenum face, GLenum a, const Real v[4])
{
  float fv[4] = { (float)v[0], (float)v[1], (float)v[2], (float)v[3] };
  glMaterialfv(face, a, fv);
}

#define glUniform1r glUniform1f

// TODO handle counts
inline void glUniform3rv(GLint loc, GLsizei count, const Real v[3])
{
  float fv[3] = { (float)v[0], (float)v[1], (float)v[2] };
  glUniform3fv(loc, count, fv);
}

inline void glUniform4rv(GLint loc, GLsizei count, const Real v[4])
{
  float fv[4] = { (float)v[0], (float)v[1], (float)v[2], (float)v[3] };
  glUniform4fv(loc, count, fv);
}

inline void glUniformMatrix4rv(GLint loc, GLsizei count, GLboolean transpose, const Real v[16])
{
  float fv[16] = {
    (float)v[0], (float)v[1], (float)v[2], (float)v[3],
    (float)v[4], (float)v[5], (float)v[6], (float)v[7],
    (float)v[8], (float)v[9], (float)v[10], (float)v[11],
    (float)v[12], (float)v[13], (float)v[14], (float)v[15]
  };
  glUniformMatrix4fv(loc, count, transpose, fv);
}

inline void glClearBufferrv(GLenum buffer, GLenum draw_buffer, const Real v[4])
{
  float f[4] = { v[0], v[1], v[2], v[3] };
  glClearBufferfv(buffer, draw_buffer, f);
}

#endif /* CHEAPER_MATH */
#end

#src
/* Make sure it generates. */
#end
