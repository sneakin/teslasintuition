#hdr
#include "canvas.h"
#include "shader_unit.h"
#include "canvas/framebuffer_texture.h"
#end

class DownSamplerShader: public ShaderUnit
{
public:
  DownSamplerShader(Renderer &renderer)
    : ShaderUnit(renderer, "shaders/basic_vertex.glsl", "shaders/downsampler_fragment.glsl", true)
  {
    relink();
  }

  virtual void bindData(ShaderProgram &shader)
  {
    shader.bind_data(FramebufferTexture::COLORS, "outColor");
  }

  virtual void updateUniforms(ShaderProgram &shader)
  {
    shader.setUniformi("tex", 0);
  }
};

class DownSampler
{
  Canvas2D &_canvas;
  DownSamplerShader _shader;
  int _samples;

public:
  DownSampler(Canvas2D &canvas, int samples = 4)
    : _canvas(canvas),
      _shader(canvas.renderer()),
      _samples(samples)
  {
  }

  int numSamples() const { return _samples; }

  void render(Texture &colors)
  {
    _canvas.bind(_shader);
    _canvas.clear();
    _canvas.pushModelViewMatrix(); {
      _canvas.setModelViewMatrix(Matrix::identity());
      _canvas.pushProjectionMatrix(); {
        _canvas.setProjectionMatrix(Matrix::orthographicProjection(0.0, 0.0, 1.0, 1.0, 100.0, -100.0));
        _canvas.setVelocity(Vec3());
        _canvas.setColor(Colors::White);
        for(int s = 0; s < _samples; s++ ) {
          Real scale = pow(0.5, s);
          _canvas.renderSprite(colors, Vec3(1.0 - scale, 0, -100), Vec3(0, 0), Vec3(scale * 0.5, scale * 0.5, 1.0), 0);
        }
      } _canvas.popProjectionMatrix();
    } _canvas.popModelViewMatrix();
  }
};
