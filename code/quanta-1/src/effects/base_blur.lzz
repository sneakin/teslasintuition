#hdr
#include "canvas.h"
#include "shader_unit.h"
#include "canvas/framebuffer_texture.h"
#end

class BaseBlurShader: public ShaderUnit
{
  int _size;
  float *_filter;

public:
  BaseBlurShader(Renderer &renderer, const char *fragment_path, int size)
    : ShaderUnit(renderer, "shaders/basic_vertex.glsl", fragment_path, true),
      _size(0),
      _filter(NULL)
  {
    setFilter(size);
    relink();
  }

  virtual ~BaseBlurShader()
  {
    delete[] _filter;
  }
  
  virtual void bindData(ShaderProgram &shader)
  {
    shader.bind_data(FramebufferTexture::COLORS, "outColor");
  }

  virtual void updateUniforms(ShaderProgram &shader)
  {
    shader.setUniformi("inColors", 0);
    updateFilter();
  }

  void setFilter(int size)
  {
    allocateFilter(size);
    computeFilter();
  }

private:
  void allocateFilter(int size)
  {
    if(_filter) delete[] _filter;
    _filter = new float[size];
    _size = size;
  }

  void computeFilter()
  {
    float n = 1.0;
    int i;
    for(i = 0; i < _size / 2; i++) {
      _filter[i] = n;
      _filter[_size - i - 1] = n;
      n = n + n;
    }
    if(_size % 2 == 1) {
      _filter[i / 2 + 1] = n;
      n = n + n;
    }
    //n = n + n;
    for(int i = 0; i < _size; i++) {
      _filter[i] = _filter[i] / n;
      std::cerr << i << "\t" << _filter[i] << std::endl;
    }
  }
  
  void updateFilter()
  {
    setUniformi("inBlurSize", _size);
    setUniformfv("inBlurFilter", _size, _filter);
  }
};

class BaseBlur
{
  Canvas2D &_canvas;
  BaseBlurShader _shader;

public:
  BaseBlur(Canvas2D &canvas, const char *blur_shader_path, int size)
    : _canvas(canvas),
      _shader(canvas.renderer(), blur_shader_path, size)
  {
  }

  virtual ~BaseBlur()
  {
  }

  void render(Texture &colors)
  {
    _canvas.bind(_shader);

    _canvas.clear();
    _canvas.pushModelViewMatrix(); {
      _canvas.setModelViewMatrix(Matrix::identity());
      _canvas.pushProjectionMatrix(); {
        _canvas.setProjectionMatrix(Matrix::orthographicProjection(-1.0, -1.0, 1.0, 1.0, 100.0, -100.0));
        _canvas.setVelocity(Vec3());
        _canvas.setColor(Colors::White());
        _canvas.renderSprite(colors, Vec3(-1, -1, -100), Vec3(0, 0), Vec3(2.0, 2.0, 1.0), 0);
      } _canvas.popProjectionMatrix();
    } _canvas.popModelViewMatrix();

    ASSERT_GL_ERROR;
  }
};
