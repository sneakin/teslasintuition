#hdr
#include "renderer.h"
#include "renderer/uniform_matrix_stack.h"
#include "renderer/material.h"

class SquareMesh;
class LineMesh;
class FramebufferTexture;

#include "shader_unit.h"
#end

#src
#include "renderer/square_mesh.h"
#include "renderer/line_mesh.h"
#include "canvas/framebuffer_texture.h"
#end


class Canvas
{
  Renderer &_renderer;
  UniformMatrixStack _modelview, _projection, _texture, _color;
  GLuint _shader_sampler_velocity, _shader_uniform_fragment_id;
  GLuint _fragment;
  GLuint _shader_uniform_color, _shader_uniform_velocity;
  Vec3 _uniform_color, _uniform_velocity;
  SquareMesh *_quad;
  LineMesh *_line;
  
public:
  Canvas(Renderer &renderer)
    : _renderer(renderer), _fragment(0), _uniform_color(Colors::White)
  {
    _quad = new SquareMesh(*this);
    _line = new LineMesh(*this);
  }

  virtual ~Canvas()
  {
    delete _quad;
    delete _line;
  }

  Renderer &renderer() { return _renderer; }

  void clear() { _renderer.clear(); }
  void flush() { _renderer.flush(); }

  void setViewport(int top, int left, int w, int h)
  {
    _renderer.setViewport(top, left, w, h);
  }

  void bindFramebuffer(FramebufferTexture &fb, bool set_viewport = true)
  {
    bindFramebuffer(fb.framebuffer());
  }
  
  void bindFramebuffer(GL3::Framebuffer &fb, bool set_viewport = true)
  {
    fb.bind();
    if(set_viewport) {
      setViewport(0, 0, fb.width(), fb.height());
    }
  }

  virtual void bind(ShaderUnit &shader)
  {
    shader.bind();
    updateUniforms(shader.shader());
  }

  void updateUniforms(ShaderProgram &shader)
  {
    _modelview.setLocation(shader.uniformLocation("mModelView"));
    _projection.setLocation(shader.uniformLocation("mProjection"));
    _texture.setLocation(shader.uniformLocation("mTexture"));
    _color.setLocation(shader.uniformLocation("mColor"));

    _shader_uniform_fragment_id = shader.uniformLocation("uFragmentId");
    resetFragmentId();

    _shader_uniform_color = shader.uniformLocation("uColor");
    setColor(_uniform_color);

    _shader_uniform_velocity = shader.uniformLocation("uVelocity");
    setVelocity(_uniform_velocity);

    // fragment shader inputs : texture unit mapping
    shader.setUniformi("tex", 0);
  }

  // vertex shader inputs
  GLuint positionAttribute() const { return 0; }
  GLuint colorAttribute() const { return 1; }
  GLuint normalAttribute() const { return 2; }
  GLuint textureCoordAttribute() const { return 3; }

  void setColor(const Vec3 &c)
  {
    _uniform_color = c;
    glUniform4rv(_shader_uniform_color, 1, c);
    ASSERT_GL_ERROR;
  }

  void pushProjectionMatrix()
  {
    _projection.push();
  }

  void popProjectionMatrix()
  {
    _projection.pop();
  }
  
  void setProjectionMatrix(const Matrix &m)
  {
    _projection.load(m);
  }

  void mulProjectionMatrix(const Matrix &m)
  {
    _projection.mul(m);
  }

  const Matrix &modelViewMatrix() const { return _modelview.top(); }
  
  void setModelViewMatrix(const Matrix &m)
  {
    _modelview.load(m);
  }

  void mulModelViewMatrix(const Matrix &m)
  {
    _modelview.mul(m);
  }

  void pushModelViewMatrix()
  {
    _modelview.push();
  }

  void popModelViewMatrix()
  {
    _modelview.pop();
  }

  Matrix textureMatrix() const
  {
    return _texture.top();
  }
  
  void setTextureMatrix(const Matrix &m)
  {
    _texture.load(m);
  }

  void pushTextureMatrix()
  {
    _texture.push();
  }

  void popTextureMatrix()
  {
    _texture.pop();
  }

  void mulTextureMatrix(const Matrix &m)
  {
    _texture.mul(m);
  }

  Matrix colorMatrix() const
  {
    return _color.top();
  }
  
  void setColorMatrix(const Matrix &m)
  {
    _color.load(m);
  }

  void pushColorMatrix()
  {
    _color.push();
  }

  void popColorMatrix()
  {
    _color.pop();
  }

  void mulColorMatrix(const Matrix &m)
  {
    _color.mul(m);
  }

  void setVelocity(const Vec3 &v)
  {
    //glUniform3rv(_shader_uniform_velocity, 1, _modelview.top() * v);
    // TODO: is the W component screwing velocity?
    _uniform_velocity = v;
    glUniform3rv(_shader_uniform_velocity, 1, _modelview.top() * (v * Vec3(1.0, 1.0, 1.0, 0.0)));
    ASSERT_GL_ERROR;
    updateFragmentId();
  }

  void updateFragmentId()
  {
    glUniform1i(_shader_uniform_fragment_id, _fragment++);
    ASSERT_GL_ERROR;
  }

  void resetFragmentId()
  {
    _fragment = 0;
    updateFragmentId();
}

  void unbindTexture()
  {
    _renderer.unbindTexture();
  }

  void blit(const Texture &tex, const Vec3 &src_pos, const Vec3 &src_size, const Vec3 &dest_pos, const Vec3 &dest_size)
  {
    _modelview.push(); {
      _texture.push(); {
        _modelview.mul(Matrix::scale(dest_size) * Matrix::translation(dest_pos));
        _texture.mul(Matrix::scale(src_size) * Matrix::translation(src_pos));
        tex.bind(0);
        ASSERT_GL_ERROR;
        _quad->bind();
        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        ASSERT_GL_ERROR;
        _quad->unbind();
        tex.unbind();
      } _texture.pop();
    } _modelview.pop();
  }
  
  void renderSprite(const Texture &tex, const Vec3 &position, const Vec3 &origin, const Vec3 &size, const Real &angle)
  {
    _modelview.push();
    _modelview.mul(Matrix::translation(-origin) * Matrix::scale(size) * Matrix::rotateZ(angle) * Matrix::translation(position));
    tex.bind(0);
    ASSERT_GL_ERROR;
    _quad->bind();
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
    ASSERT_GL_ERROR;
    _quad->unbind();
    _modelview.pop();
    tex.unbind();
  }

 void renderCameraAxis(const Camera &camera)
  {
    renderAxis(camera.position(), camera.right(), camera.up());
    pushColorMatrix(); {
      mulColorMatrix(Matrix::rotate(Vec3(M_PI / 4.0, M_PI / 4.0, M_PI / 4.0)));
      renderAxis(camera.position(), Vec3::X, Vec3::Y);
    } popColorMatrix();
  }

  virtual void renderOriginAxis()
  {
    renderVector(Vec3(), Vec3::X, Colors::Red);
    renderVector(Vec3(), Vec3::Y, Colors::Green);
    renderVector(Vec3(), Vec3::Z, Colors::Blue);
  }

  void renderAxis(const Vec3 &origin, const Vec3 &right = Vec3::X, const Vec3 &up = Vec3::Y)
  {
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::lookAt(up.cross(right), up) * Matrix::translation(origin));
      renderOriginAxis();
    } popModelViewMatrix();
  }

  void renderVector(const Vec3 &origin, const Vec3 &v, const Vec3 &color = Colors::White)
  {
    ASSERT_GL_ERROR;
    glLineWidth(4.0);
    glPointSize(10.0);
    ASSERT_GL_ERROR;
    setColor(color);
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::scale(v * Vec3(1.0, 1.0, 1.0, 0.0) + Vec3::W) * Matrix::translation(origin));
      _line->bind();
      glDrawArrays(GL_LINES, 0, 2);
      _line->unbind();
    } popModelViewMatrix();
    ASSERT_GL_ERROR;
  }

  void renderPoint(const Vec3 &position, const Vec3 &color = Colors::White, Real diameter = 1.0)
  {
    ASSERT_GL_ERROR;
    glPointSize(clamp<Real>(diameter, 10.0));
    setColor(color);
    pushModelViewMatrix(); {
      mulModelViewMatrix(Matrix::translation(position));
      _line->bind();
      glDrawArrays(GL_POINTS, 0, 1);
      _line->unbind();
    } popModelViewMatrix();
    ASSERT_GL_ERROR;
  }

  void renderLine(const Vec3 &a, const Vec3 &b, const Vec3 &color = Colors::White)
  {
    renderVector(a, b - a, color);
  }
};

class Canvas2D: public Canvas
{
public:
  Canvas2D(Renderer &renderer)
    : Canvas(renderer)
  {
  }
};

class Canvas3D: public Canvas
{
  GLuint _shader_uniform_forward, _shader_uniform_camera;
  GLuint _shader_uniform_light0_position, _shader_uniform_light0_intensity, _shader_uniform_light0_color, _shader_uniform_ambient_light;
  GLuint _shader_uniform_material_shine, _shader_uniform_material_specular, _shader_uniform_material_diffuse, _shader_uniform_material_ambient, _shader_uniform_material_emission;
  Material _material;
  
public:
  static const Material AxisMaterial = Material(Colors::Clear, Colors::Clear, 0.0, Colors::White, Colors::White);
  
  Canvas3D(Renderer &renderer)
    : Canvas(renderer)
  {
  }

  virtual void bind(ShaderUnit &shader)
  {
    Canvas::bind(shader);

    _shader_uniform_light0_position = shader.uniformLocation("uLight.position");
    _shader_uniform_light0_intensity = shader.uniformLocation("uLight.intensity");
    _shader_uniform_light0_color = shader.uniformLocation("uLight.color");
    _shader_uniform_ambient_light = shader.uniformLocation("uAmbientLight");

    _shader_uniform_forward = shader.uniformLocation("uForward");
    _shader_uniform_camera = shader.uniformLocation("uCamera");

    _shader_uniform_material_shine = shader.uniformLocation("uMaterial.shine");
    _shader_uniform_material_specular = shader.uniformLocation("uMaterial.specular");
    _shader_uniform_material_diffuse = shader.uniformLocation("uMaterial.diffuse");
    _shader_uniform_material_ambient = shader.uniformLocation("uMaterial.ambient");
    _shader_uniform_material_emission = shader.uniformLocation("uMaterial.emission");

    bindMaterial(GL_FRONT_AND_BACK, _material);
  }

  void setCamera(const Camera &camera)
  {
    glUniform3rv(_shader_uniform_forward, 1, camera.forward());
    glUniform3rv(_shader_uniform_camera, 1, camera.position());
    setModelViewMatrix(camera.matrix().invert());
  }
  
  uint32_t createPointLight(const Vec3 &position, Real attenuation, const Vec3 &color)
  {
    moveLight(0, position);
    glUniform1r(_shader_uniform_light0_intensity, attenuation);
    ASSERT_GL_ERROR;
    glUniform3rv(_shader_uniform_light0_color, 1, color);
    ASSERT_GL_ERROR;
    return 0;
  }

  void setAmbientLight(const Vec3 &color)
  {
    glUniform3rv(_shader_uniform_ambient_light, 1, color);
    ASSERT_GL_ERROR;
  }

  void moveLight(uint32_t id, const Vec3 &position)
  {
    glUniform4rv(_shader_uniform_light0_position, 1, modelViewMatrix() * position);
    ASSERT_GL_ERROR;
  }

  void bindMaterial(GLenum face, const Material &m)
  {
    if(face == GL_FRONT_AND_BACK) {
      bindMaterial(GL_FRONT, m);
      bindMaterial(GL_BACK, m);
    } else {
      _material = m; // TODO detect if useProgram was called
      glUniform1r(_shader_uniform_material_shine, m.shininess());
      glUniform4rv(_shader_uniform_material_specular, 1, m.specular());
      glUniform4rv(_shader_uniform_material_emission, 1, m.emission());
      glUniform4rv(_shader_uniform_material_ambient, 1, m.ambient());
      glUniform4rv(_shader_uniform_material_diffuse, 1, m.diffuse());
    }

    ASSERT_GL_ERROR;
  }

  void unbindMaterial(GLenum face)
  {
    bindMaterial(face, Material::Default);
  }

  virtual void renderOriginAxis()
  {
    bindMaterial(GL_FRONT_AND_BACK, AxisMaterial);
    Canvas::renderOriginAxis();
    unbindMaterial(GL_FRONT_AND_BACK);
  }
};
