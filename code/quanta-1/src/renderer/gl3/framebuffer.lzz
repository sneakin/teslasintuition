#hdr
#include "gl.h"
#include "vec3.h"
#include "real.h"
#include "renderer/texture.h"
#include "renderer/gl3/renderbuffer.h"
#end

namespace GL3
{
  class Framebuffer
  {
    GLuint _id;
    GLenum _mode;
    GLuint _width, _height;
    
  public:
    Framebuffer()
      : _mode(GL_FRAMEBUFFER), _width(0), _height(0)
    {
      glGenFramebuffers(1, &_id);
      ASSERT_GL_ERROR;
    }

    Framebuffer(GLint id, int w = 0, int h = 0)
      : _mode(GL_FRAMEBUFFER), _width(w), _height(h)
    {
      _id = id;
    }    
    
    ~Framebuffer()
    {
      if(_id != 0) {
        glDeleteFramebuffers(1, &_id);
        ASSERT_GL_ERROR;
      }
    }

    GLuint id() const { return _id; }
    GLuint width() const { return _width; }
    GLuint height() const { return _height; }

    void resize(int w, int h)
    {
      _width = w;
      _height = h;
    }

    void bind(GLenum mode = GL_FRAMEBUFFER)
    {
      _mode = mode;
      glBindFramebuffer(_mode, _id);
      ASSERT_GL_ERROR;
    }

    void unbind()
    {
      glBindFramebuffer(_mode, 0);
      ASSERT_GL_ERROR;
    }

    void attachTexture(GLenum target, const Texture &tex)
    {
      bind();
      glFramebufferTexture2D(_mode, target, GL_TEXTURE_2D, tex.id(), 0);
      ASSERT_GL_ERROR;
    }

    void drawTo(GLsizei n, GLenum buffers[])
    {
      bind();
      glDrawBuffers(n, buffers);
      ASSERT_GL_ERROR;
    }

    void clear(GLuint n, const Vec3 &color)
    {
      bind();
      glClearBufferrv(GL_COLOR, n, color);
      ASSERT_GL_ERROR;
    }

    void attachRenderbuffer(GLenum target, const GL3::Renderbuffer &rb)
    {
      bind();
      glFramebufferRenderbuffer(_mode, target, GL_RENDERBUFFER, rb.id());
      ASSERT_GL_ERROR;
    }

    bool isComplete()
    {
      bind();
      return glCheckFramebufferStatus(_mode) == GL_FRAMEBUFFER_COMPLETE;
    }
  };
}
